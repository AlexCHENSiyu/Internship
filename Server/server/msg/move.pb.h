// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: move.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_move_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_move_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_move_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_move_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_move_2eproto;
class BaseMsg;
struct BaseMsgDefaultTypeInternal;
extern BaseMsgDefaultTypeInternal _BaseMsg_default_instance_;
class ChessMapMsg;
struct ChessMapMsgDefaultTypeInternal;
extern ChessMapMsgDefaultTypeInternal _ChessMapMsg_default_instance_;
class JoinRoomMsg;
struct JoinRoomMsgDefaultTypeInternal;
extern JoinRoomMsgDefaultTypeInternal _JoinRoomMsg_default_instance_;
class LeaveRoomMsg;
struct LeaveRoomMsgDefaultTypeInternal;
extern LeaveRoomMsgDefaultTypeInternal _LeaveRoomMsg_default_instance_;
class MessageMsg;
struct MessageMsgDefaultTypeInternal;
extern MessageMsgDefaultTypeInternal _MessageMsg_default_instance_;
class MoveMsg;
struct MoveMsgDefaultTypeInternal;
extern MoveMsgDefaultTypeInternal _MoveMsg_default_instance_;
class OrderMsg;
struct OrderMsgDefaultTypeInternal;
extern OrderMsgDefaultTypeInternal _OrderMsg_default_instance_;
class ResultMsg;
struct ResultMsgDefaultTypeInternal;
extern ResultMsgDefaultTypeInternal _ResultMsg_default_instance_;
class RoomMsg;
struct RoomMsgDefaultTypeInternal;
extern RoomMsgDefaultTypeInternal _RoomMsg_default_instance_;
class RoomsMsg;
struct RoomsMsgDefaultTypeInternal;
extern RoomsMsgDefaultTypeInternal _RoomsMsg_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::BaseMsg* Arena::CreateMaybeMessage<::BaseMsg>(Arena*);
template<> ::ChessMapMsg* Arena::CreateMaybeMessage<::ChessMapMsg>(Arena*);
template<> ::JoinRoomMsg* Arena::CreateMaybeMessage<::JoinRoomMsg>(Arena*);
template<> ::LeaveRoomMsg* Arena::CreateMaybeMessage<::LeaveRoomMsg>(Arena*);
template<> ::MessageMsg* Arena::CreateMaybeMessage<::MessageMsg>(Arena*);
template<> ::MoveMsg* Arena::CreateMaybeMessage<::MoveMsg>(Arena*);
template<> ::OrderMsg* Arena::CreateMaybeMessage<::OrderMsg>(Arena*);
template<> ::ResultMsg* Arena::CreateMaybeMessage<::ResultMsg>(Arena*);
template<> ::RoomMsg* Arena::CreateMaybeMessage<::RoomMsg>(Arena*);
template<> ::RoomsMsg* Arena::CreateMaybeMessage<::RoomsMsg>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum MsgType : int {
  BaseMsgType = 0,
  JoinRoomMsgType = 1,
  LeaveRoomMsgType = 2,
  RoomsMsgType = 3,
  MoveMsgType = 4,
  MessageMsgType = 5,
  OrderMsgType = 6,
  ChessMapMsgType = 7,
  ResultMsgType = 8,
  MsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MsgType_IsValid(int value);
constexpr MsgType MsgType_MIN = BaseMsgType;
constexpr MsgType MsgType_MAX = ResultMsgType;
constexpr int MsgType_ARRAYSIZE = MsgType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgType_descriptor();
template<typename T>
inline const std::string& MsgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgType_descriptor(), enum_t_value);
}
inline bool MsgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgType>(
    MsgType_descriptor(), name, value);
}
// ===================================================================

class BaseMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BaseMsg) */ {
 public:
  inline BaseMsg() : BaseMsg(nullptr) {}
  ~BaseMsg() override;
  explicit PROTOBUF_CONSTEXPR BaseMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaseMsg(const BaseMsg& from);
  BaseMsg(BaseMsg&& from) noexcept
    : BaseMsg() {
    *this = ::std::move(from);
  }

  inline BaseMsg& operator=(const BaseMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseMsg& operator=(BaseMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaseMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaseMsg* internal_default_instance() {
    return reinterpret_cast<const BaseMsg*>(
               &_BaseMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BaseMsg& a, BaseMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BaseMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BaseMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaseMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BaseMsg& from) {
    BaseMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BaseMsg";
  }
  protected:
  explicit BaseMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgTypeFieldNumber = 1,
  };
  // .MsgType msg_type = 1;
  void clear_msg_type();
  ::MsgType msg_type() const;
  void set_msg_type(::MsgType value);
  private:
  ::MsgType _internal_msg_type() const;
  void _internal_set_msg_type(::MsgType value);
  public:

  // @@protoc_insertion_point(class_scope:BaseMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int msg_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_move_2eproto;
};
// -------------------------------------------------------------------

class JoinRoomMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:JoinRoomMsg) */ {
 public:
  inline JoinRoomMsg() : JoinRoomMsg(nullptr) {}
  ~JoinRoomMsg() override;
  explicit PROTOBUF_CONSTEXPR JoinRoomMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JoinRoomMsg(const JoinRoomMsg& from);
  JoinRoomMsg(JoinRoomMsg&& from) noexcept
    : JoinRoomMsg() {
    *this = ::std::move(from);
  }

  inline JoinRoomMsg& operator=(const JoinRoomMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinRoomMsg& operator=(JoinRoomMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinRoomMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinRoomMsg* internal_default_instance() {
    return reinterpret_cast<const JoinRoomMsg*>(
               &_JoinRoomMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(JoinRoomMsg& a, JoinRoomMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinRoomMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinRoomMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinRoomMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinRoomMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const JoinRoomMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const JoinRoomMsg& from) {
    JoinRoomMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinRoomMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "JoinRoomMsg";
  }
  protected:
  explicit JoinRoomMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgTypeFieldNumber = 1,
    kRoomIdFieldNumber = 2,
    kJoinFieldNumber = 3,
    kPlayerFieldNumber = 4,
  };
  // .MsgType msg_type = 1;
  void clear_msg_type();
  ::MsgType msg_type() const;
  void set_msg_type(::MsgType value);
  private:
  ::MsgType _internal_msg_type() const;
  void _internal_set_msg_type(::MsgType value);
  public:

  // int32 RoomId = 2;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // bool join = 3;
  void clear_join();
  bool join() const;
  void set_join(bool value);
  private:
  bool _internal_join() const;
  void _internal_set_join(bool value);
  public:

  // bool player = 4;
  void clear_player();
  bool player() const;
  void set_player(bool value);
  private:
  bool _internal_player() const;
  void _internal_set_player(bool value);
  public:

  // @@protoc_insertion_point(class_scope:JoinRoomMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int msg_type_;
    int32_t roomid_;
    bool join_;
    bool player_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_move_2eproto;
};
// -------------------------------------------------------------------

class LeaveRoomMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LeaveRoomMsg) */ {
 public:
  inline LeaveRoomMsg() : LeaveRoomMsg(nullptr) {}
  ~LeaveRoomMsg() override;
  explicit PROTOBUF_CONSTEXPR LeaveRoomMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeaveRoomMsg(const LeaveRoomMsg& from);
  LeaveRoomMsg(LeaveRoomMsg&& from) noexcept
    : LeaveRoomMsg() {
    *this = ::std::move(from);
  }

  inline LeaveRoomMsg& operator=(const LeaveRoomMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveRoomMsg& operator=(LeaveRoomMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaveRoomMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaveRoomMsg* internal_default_instance() {
    return reinterpret_cast<const LeaveRoomMsg*>(
               &_LeaveRoomMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LeaveRoomMsg& a, LeaveRoomMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(LeaveRoomMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveRoomMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaveRoomMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeaveRoomMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeaveRoomMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LeaveRoomMsg& from) {
    LeaveRoomMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeaveRoomMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LeaveRoomMsg";
  }
  protected:
  explicit LeaveRoomMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgTypeFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kLeaveFieldNumber = 3,
  };
  // .MsgType msg_type = 1;
  void clear_msg_type();
  ::MsgType msg_type() const;
  void set_msg_type(::MsgType value);
  private:
  ::MsgType _internal_msg_type() const;
  void _internal_set_msg_type(::MsgType value);
  public:

  // int32 clientId = 2;
  void clear_clientid();
  int32_t clientid() const;
  void set_clientid(int32_t value);
  private:
  int32_t _internal_clientid() const;
  void _internal_set_clientid(int32_t value);
  public:

  // bool leave = 3;
  void clear_leave();
  bool leave() const;
  void set_leave(bool value);
  private:
  bool _internal_leave() const;
  void _internal_set_leave(bool value);
  public:

  // @@protoc_insertion_point(class_scope:LeaveRoomMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int msg_type_;
    int32_t clientid_;
    bool leave_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_move_2eproto;
};
// -------------------------------------------------------------------

class RoomMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoomMsg) */ {
 public:
  inline RoomMsg() : RoomMsg(nullptr) {}
  ~RoomMsg() override;
  explicit PROTOBUF_CONSTEXPR RoomMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomMsg(const RoomMsg& from);
  RoomMsg(RoomMsg&& from) noexcept
    : RoomMsg() {
    *this = ::std::move(from);
  }

  inline RoomMsg& operator=(const RoomMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomMsg& operator=(RoomMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomMsg* internal_default_instance() {
    return reinterpret_cast<const RoomMsg*>(
               &_RoomMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RoomMsg& a, RoomMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoomMsg& from) {
    RoomMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoomMsg";
  }
  protected:
  explicit RoomMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
    kNumPeopleFieldNumber = 2,
  };
  // int32 roomId = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // int32 num_people = 2;
  void clear_num_people();
  int32_t num_people() const;
  void set_num_people(int32_t value);
  private:
  int32_t _internal_num_people() const;
  void _internal_set_num_people(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RoomMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t roomid_;
    int32_t num_people_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_move_2eproto;
};
// -------------------------------------------------------------------

class RoomsMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RoomsMsg) */ {
 public:
  inline RoomsMsg() : RoomsMsg(nullptr) {}
  ~RoomsMsg() override;
  explicit PROTOBUF_CONSTEXPR RoomsMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomsMsg(const RoomsMsg& from);
  RoomsMsg(RoomsMsg&& from) noexcept
    : RoomsMsg() {
    *this = ::std::move(from);
  }

  inline RoomsMsg& operator=(const RoomsMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomsMsg& operator=(RoomsMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomsMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomsMsg* internal_default_instance() {
    return reinterpret_cast<const RoomsMsg*>(
               &_RoomsMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RoomsMsg& a, RoomsMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomsMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomsMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomsMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomsMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomsMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RoomsMsg& from) {
    RoomsMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomsMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RoomsMsg";
  }
  protected:
  explicit RoomsMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomsFieldNumber = 10,
    kMsgTypeFieldNumber = 1,
    kClientIdFieldNumber = 2,
  };
  // repeated .RoomMsg rooms = 10;
  int rooms_size() const;
  private:
  int _internal_rooms_size() const;
  public:
  void clear_rooms();
  ::RoomMsg* mutable_rooms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomMsg >*
      mutable_rooms();
  private:
  const ::RoomMsg& _internal_rooms(int index) const;
  ::RoomMsg* _internal_add_rooms();
  public:
  const ::RoomMsg& rooms(int index) const;
  ::RoomMsg* add_rooms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomMsg >&
      rooms() const;

  // .MsgType msg_type = 1;
  void clear_msg_type();
  ::MsgType msg_type() const;
  void set_msg_type(::MsgType value);
  private:
  ::MsgType _internal_msg_type() const;
  void _internal_set_msg_type(::MsgType value);
  public:

  // int32 clientId = 2;
  void clear_clientid();
  int32_t clientid() const;
  void set_clientid(int32_t value);
  private:
  int32_t _internal_clientid() const;
  void _internal_set_clientid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RoomsMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomMsg > rooms_;
    int msg_type_;
    int32_t clientid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_move_2eproto;
};
// -------------------------------------------------------------------

class MoveMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MoveMsg) */ {
 public:
  inline MoveMsg() : MoveMsg(nullptr) {}
  ~MoveMsg() override;
  explicit PROTOBUF_CONSTEXPR MoveMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveMsg(const MoveMsg& from);
  MoveMsg(MoveMsg&& from) noexcept
    : MoveMsg() {
    *this = ::std::move(from);
  }

  inline MoveMsg& operator=(const MoveMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveMsg& operator=(MoveMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveMsg* internal_default_instance() {
    return reinterpret_cast<const MoveMsg*>(
               &_MoveMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MoveMsg& a, MoveMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveMsg& from) {
    MoveMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MoveMsg";
  }
  protected:
  explicit MoveMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgTypeFieldNumber = 1,
    kMoveXFieldNumber = 2,
    kMoveYFieldNumber = 3,
    kValidationFieldNumber = 4,
  };
  // .MsgType msg_type = 1;
  void clear_msg_type();
  ::MsgType msg_type() const;
  void set_msg_type(::MsgType value);
  private:
  ::MsgType _internal_msg_type() const;
  void _internal_set_msg_type(::MsgType value);
  public:

  // int32 move_x = 2;
  void clear_move_x();
  int32_t move_x() const;
  void set_move_x(int32_t value);
  private:
  int32_t _internal_move_x() const;
  void _internal_set_move_x(int32_t value);
  public:

  // int32 move_y = 3;
  void clear_move_y();
  int32_t move_y() const;
  void set_move_y(int32_t value);
  private:
  int32_t _internal_move_y() const;
  void _internal_set_move_y(int32_t value);
  public:

  // bool validation = 4;
  void clear_validation();
  bool validation() const;
  void set_validation(bool value);
  private:
  bool _internal_validation() const;
  void _internal_set_validation(bool value);
  public:

  // @@protoc_insertion_point(class_scope:MoveMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int msg_type_;
    int32_t move_x_;
    int32_t move_y_;
    bool validation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_move_2eproto;
};
// -------------------------------------------------------------------

class MessageMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MessageMsg) */ {
 public:
  inline MessageMsg() : MessageMsg(nullptr) {}
  ~MessageMsg() override;
  explicit PROTOBUF_CONSTEXPR MessageMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageMsg(const MessageMsg& from);
  MessageMsg(MessageMsg&& from) noexcept
    : MessageMsg() {
    *this = ::std::move(from);
  }

  inline MessageMsg& operator=(const MessageMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageMsg& operator=(MessageMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageMsg* internal_default_instance() {
    return reinterpret_cast<const MessageMsg*>(
               &_MessageMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MessageMsg& a, MessageMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessageMsg& from) {
    MessageMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MessageMsg";
  }
  protected:
  explicit MessageMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kMsgTypeFieldNumber = 1,
    kClientIdFieldNumber = 3,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .MsgType msg_type = 1;
  void clear_msg_type();
  ::MsgType msg_type() const;
  void set_msg_type(::MsgType value);
  private:
  ::MsgType _internal_msg_type() const;
  void _internal_set_msg_type(::MsgType value);
  public:

  // int32 clientId = 3;
  void clear_clientid();
  int32_t clientid() const;
  void set_clientid(int32_t value);
  private:
  int32_t _internal_clientid() const;
  void _internal_set_clientid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MessageMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int msg_type_;
    int32_t clientid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_move_2eproto;
};
// -------------------------------------------------------------------

class OrderMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OrderMsg) */ {
 public:
  inline OrderMsg() : OrderMsg(nullptr) {}
  ~OrderMsg() override;
  explicit PROTOBUF_CONSTEXPR OrderMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrderMsg(const OrderMsg& from);
  OrderMsg(OrderMsg&& from) noexcept
    : OrderMsg() {
    *this = ::std::move(from);
  }

  inline OrderMsg& operator=(const OrderMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrderMsg& operator=(OrderMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrderMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrderMsg* internal_default_instance() {
    return reinterpret_cast<const OrderMsg*>(
               &_OrderMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OrderMsg& a, OrderMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(OrderMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrderMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrderMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrderMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrderMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OrderMsg& from) {
    OrderMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OrderMsg";
  }
  protected:
  explicit OrderMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgTypeFieldNumber = 1,
    kWhiteFieldNumber = 2,
    kBlackFieldNumber = 3,
    kGamestartFieldNumber = 4,
  };
  // .MsgType msg_type = 1;
  void clear_msg_type();
  ::MsgType msg_type() const;
  void set_msg_type(::MsgType value);
  private:
  ::MsgType _internal_msg_type() const;
  void _internal_set_msg_type(::MsgType value);
  public:

  // int32 white = 2;
  void clear_white();
  int32_t white() const;
  void set_white(int32_t value);
  private:
  int32_t _internal_white() const;
  void _internal_set_white(int32_t value);
  public:

  // int32 black = 3;
  void clear_black();
  int32_t black() const;
  void set_black(int32_t value);
  private:
  int32_t _internal_black() const;
  void _internal_set_black(int32_t value);
  public:

  // bool gamestart = 4;
  void clear_gamestart();
  bool gamestart() const;
  void set_gamestart(bool value);
  private:
  bool _internal_gamestart() const;
  void _internal_set_gamestart(bool value);
  public:

  // @@protoc_insertion_point(class_scope:OrderMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int msg_type_;
    int32_t white_;
    int32_t black_;
    bool gamestart_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_move_2eproto;
};
// -------------------------------------------------------------------

class ChessMapMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChessMapMsg) */ {
 public:
  inline ChessMapMsg() : ChessMapMsg(nullptr) {}
  ~ChessMapMsg() override;
  explicit PROTOBUF_CONSTEXPR ChessMapMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChessMapMsg(const ChessMapMsg& from);
  ChessMapMsg(ChessMapMsg&& from) noexcept
    : ChessMapMsg() {
    *this = ::std::move(from);
  }

  inline ChessMapMsg& operator=(const ChessMapMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChessMapMsg& operator=(ChessMapMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChessMapMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChessMapMsg* internal_default_instance() {
    return reinterpret_cast<const ChessMapMsg*>(
               &_ChessMapMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ChessMapMsg& a, ChessMapMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(ChessMapMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChessMapMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChessMapMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChessMapMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChessMapMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChessMapMsg& from) {
    ChessMapMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChessMapMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChessMapMsg";
  }
  protected:
  explicit ChessMapMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapFieldNumber = 2,
    kMsgTypeFieldNumber = 1,
    kStepFieldNumber = 3,
  };
  // repeated int32 map = 2;
  int map_size() const;
  private:
  int _internal_map_size() const;
  public:
  void clear_map();
  private:
  int32_t _internal_map(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_map() const;
  void _internal_add_map(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_map();
  public:
  int32_t map(int index) const;
  void set_map(int index, int32_t value);
  void add_map(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      map() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_map();

  // .MsgType msg_type = 1;
  void clear_msg_type();
  ::MsgType msg_type() const;
  void set_msg_type(::MsgType value);
  private:
  ::MsgType _internal_msg_type() const;
  void _internal_set_msg_type(::MsgType value);
  public:

  // int32 step = 3;
  void clear_step();
  int32_t step() const;
  void set_step(int32_t value);
  private:
  int32_t _internal_step() const;
  void _internal_set_step(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChessMapMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > map_;
    mutable std::atomic<int> _map_cached_byte_size_;
    int msg_type_;
    int32_t step_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_move_2eproto;
};
// -------------------------------------------------------------------

class ResultMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResultMsg) */ {
 public:
  inline ResultMsg() : ResultMsg(nullptr) {}
  ~ResultMsg() override;
  explicit PROTOBUF_CONSTEXPR ResultMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResultMsg(const ResultMsg& from);
  ResultMsg(ResultMsg&& from) noexcept
    : ResultMsg() {
    *this = ::std::move(from);
  }

  inline ResultMsg& operator=(const ResultMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultMsg& operator=(ResultMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResultMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResultMsg* internal_default_instance() {
    return reinterpret_cast<const ResultMsg*>(
               &_ResultMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ResultMsg& a, ResultMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(ResultMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResultMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResultMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResultMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResultMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResultMsg& from) {
    ResultMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResultMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResultMsg";
  }
  protected:
  explicit ResultMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgTypeFieldNumber = 1,
    kColorFieldNumber = 2,
  };
  // .MsgType msg_type = 1;
  void clear_msg_type();
  ::MsgType msg_type() const;
  void set_msg_type(::MsgType value);
  private:
  ::MsgType _internal_msg_type() const;
  void _internal_set_msg_type(::MsgType value);
  public:

  // int32 color = 2;
  void clear_color();
  int32_t color() const;
  void set_color(int32_t value);
  private:
  int32_t _internal_color() const;
  void _internal_set_color(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ResultMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int msg_type_;
    int32_t color_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_move_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BaseMsg

// .MsgType msg_type = 1;
inline void BaseMsg::clear_msg_type() {
  _impl_.msg_type_ = 0;
}
inline ::MsgType BaseMsg::_internal_msg_type() const {
  return static_cast< ::MsgType >(_impl_.msg_type_);
}
inline ::MsgType BaseMsg::msg_type() const {
  // @@protoc_insertion_point(field_get:BaseMsg.msg_type)
  return _internal_msg_type();
}
inline void BaseMsg::_internal_set_msg_type(::MsgType value) {
  
  _impl_.msg_type_ = value;
}
inline void BaseMsg::set_msg_type(::MsgType value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:BaseMsg.msg_type)
}

// -------------------------------------------------------------------

// JoinRoomMsg

// .MsgType msg_type = 1;
inline void JoinRoomMsg::clear_msg_type() {
  _impl_.msg_type_ = 0;
}
inline ::MsgType JoinRoomMsg::_internal_msg_type() const {
  return static_cast< ::MsgType >(_impl_.msg_type_);
}
inline ::MsgType JoinRoomMsg::msg_type() const {
  // @@protoc_insertion_point(field_get:JoinRoomMsg.msg_type)
  return _internal_msg_type();
}
inline void JoinRoomMsg::_internal_set_msg_type(::MsgType value) {
  
  _impl_.msg_type_ = value;
}
inline void JoinRoomMsg::set_msg_type(::MsgType value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:JoinRoomMsg.msg_type)
}

// int32 RoomId = 2;
inline void JoinRoomMsg::clear_roomid() {
  _impl_.roomid_ = 0;
}
inline int32_t JoinRoomMsg::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t JoinRoomMsg::roomid() const {
  // @@protoc_insertion_point(field_get:JoinRoomMsg.RoomId)
  return _internal_roomid();
}
inline void JoinRoomMsg::_internal_set_roomid(int32_t value) {
  
  _impl_.roomid_ = value;
}
inline void JoinRoomMsg::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:JoinRoomMsg.RoomId)
}

// bool join = 3;
inline void JoinRoomMsg::clear_join() {
  _impl_.join_ = false;
}
inline bool JoinRoomMsg::_internal_join() const {
  return _impl_.join_;
}
inline bool JoinRoomMsg::join() const {
  // @@protoc_insertion_point(field_get:JoinRoomMsg.join)
  return _internal_join();
}
inline void JoinRoomMsg::_internal_set_join(bool value) {
  
  _impl_.join_ = value;
}
inline void JoinRoomMsg::set_join(bool value) {
  _internal_set_join(value);
  // @@protoc_insertion_point(field_set:JoinRoomMsg.join)
}

// bool player = 4;
inline void JoinRoomMsg::clear_player() {
  _impl_.player_ = false;
}
inline bool JoinRoomMsg::_internal_player() const {
  return _impl_.player_;
}
inline bool JoinRoomMsg::player() const {
  // @@protoc_insertion_point(field_get:JoinRoomMsg.player)
  return _internal_player();
}
inline void JoinRoomMsg::_internal_set_player(bool value) {
  
  _impl_.player_ = value;
}
inline void JoinRoomMsg::set_player(bool value) {
  _internal_set_player(value);
  // @@protoc_insertion_point(field_set:JoinRoomMsg.player)
}

// -------------------------------------------------------------------

// LeaveRoomMsg

// .MsgType msg_type = 1;
inline void LeaveRoomMsg::clear_msg_type() {
  _impl_.msg_type_ = 0;
}
inline ::MsgType LeaveRoomMsg::_internal_msg_type() const {
  return static_cast< ::MsgType >(_impl_.msg_type_);
}
inline ::MsgType LeaveRoomMsg::msg_type() const {
  // @@protoc_insertion_point(field_get:LeaveRoomMsg.msg_type)
  return _internal_msg_type();
}
inline void LeaveRoomMsg::_internal_set_msg_type(::MsgType value) {
  
  _impl_.msg_type_ = value;
}
inline void LeaveRoomMsg::set_msg_type(::MsgType value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:LeaveRoomMsg.msg_type)
}

// int32 clientId = 2;
inline void LeaveRoomMsg::clear_clientid() {
  _impl_.clientid_ = 0;
}
inline int32_t LeaveRoomMsg::_internal_clientid() const {
  return _impl_.clientid_;
}
inline int32_t LeaveRoomMsg::clientid() const {
  // @@protoc_insertion_point(field_get:LeaveRoomMsg.clientId)
  return _internal_clientid();
}
inline void LeaveRoomMsg::_internal_set_clientid(int32_t value) {
  
  _impl_.clientid_ = value;
}
inline void LeaveRoomMsg::set_clientid(int32_t value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:LeaveRoomMsg.clientId)
}

// bool leave = 3;
inline void LeaveRoomMsg::clear_leave() {
  _impl_.leave_ = false;
}
inline bool LeaveRoomMsg::_internal_leave() const {
  return _impl_.leave_;
}
inline bool LeaveRoomMsg::leave() const {
  // @@protoc_insertion_point(field_get:LeaveRoomMsg.leave)
  return _internal_leave();
}
inline void LeaveRoomMsg::_internal_set_leave(bool value) {
  
  _impl_.leave_ = value;
}
inline void LeaveRoomMsg::set_leave(bool value) {
  _internal_set_leave(value);
  // @@protoc_insertion_point(field_set:LeaveRoomMsg.leave)
}

// -------------------------------------------------------------------

// RoomMsg

// int32 roomId = 1;
inline void RoomMsg::clear_roomid() {
  _impl_.roomid_ = 0;
}
inline int32_t RoomMsg::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t RoomMsg::roomid() const {
  // @@protoc_insertion_point(field_get:RoomMsg.roomId)
  return _internal_roomid();
}
inline void RoomMsg::_internal_set_roomid(int32_t value) {
  
  _impl_.roomid_ = value;
}
inline void RoomMsg::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:RoomMsg.roomId)
}

// int32 num_people = 2;
inline void RoomMsg::clear_num_people() {
  _impl_.num_people_ = 0;
}
inline int32_t RoomMsg::_internal_num_people() const {
  return _impl_.num_people_;
}
inline int32_t RoomMsg::num_people() const {
  // @@protoc_insertion_point(field_get:RoomMsg.num_people)
  return _internal_num_people();
}
inline void RoomMsg::_internal_set_num_people(int32_t value) {
  
  _impl_.num_people_ = value;
}
inline void RoomMsg::set_num_people(int32_t value) {
  _internal_set_num_people(value);
  // @@protoc_insertion_point(field_set:RoomMsg.num_people)
}

// -------------------------------------------------------------------

// RoomsMsg

// .MsgType msg_type = 1;
inline void RoomsMsg::clear_msg_type() {
  _impl_.msg_type_ = 0;
}
inline ::MsgType RoomsMsg::_internal_msg_type() const {
  return static_cast< ::MsgType >(_impl_.msg_type_);
}
inline ::MsgType RoomsMsg::msg_type() const {
  // @@protoc_insertion_point(field_get:RoomsMsg.msg_type)
  return _internal_msg_type();
}
inline void RoomsMsg::_internal_set_msg_type(::MsgType value) {
  
  _impl_.msg_type_ = value;
}
inline void RoomsMsg::set_msg_type(::MsgType value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:RoomsMsg.msg_type)
}

// int32 clientId = 2;
inline void RoomsMsg::clear_clientid() {
  _impl_.clientid_ = 0;
}
inline int32_t RoomsMsg::_internal_clientid() const {
  return _impl_.clientid_;
}
inline int32_t RoomsMsg::clientid() const {
  // @@protoc_insertion_point(field_get:RoomsMsg.clientId)
  return _internal_clientid();
}
inline void RoomsMsg::_internal_set_clientid(int32_t value) {
  
  _impl_.clientid_ = value;
}
inline void RoomsMsg::set_clientid(int32_t value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:RoomsMsg.clientId)
}

// repeated .RoomMsg rooms = 10;
inline int RoomsMsg::_internal_rooms_size() const {
  return _impl_.rooms_.size();
}
inline int RoomsMsg::rooms_size() const {
  return _internal_rooms_size();
}
inline void RoomsMsg::clear_rooms() {
  _impl_.rooms_.Clear();
}
inline ::RoomMsg* RoomsMsg::mutable_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:RoomsMsg.rooms)
  return _impl_.rooms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomMsg >*
RoomsMsg::mutable_rooms() {
  // @@protoc_insertion_point(field_mutable_list:RoomsMsg.rooms)
  return &_impl_.rooms_;
}
inline const ::RoomMsg& RoomsMsg::_internal_rooms(int index) const {
  return _impl_.rooms_.Get(index);
}
inline const ::RoomMsg& RoomsMsg::rooms(int index) const {
  // @@protoc_insertion_point(field_get:RoomsMsg.rooms)
  return _internal_rooms(index);
}
inline ::RoomMsg* RoomsMsg::_internal_add_rooms() {
  return _impl_.rooms_.Add();
}
inline ::RoomMsg* RoomsMsg::add_rooms() {
  ::RoomMsg* _add = _internal_add_rooms();
  // @@protoc_insertion_point(field_add:RoomsMsg.rooms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::RoomMsg >&
RoomsMsg::rooms() const {
  // @@protoc_insertion_point(field_list:RoomsMsg.rooms)
  return _impl_.rooms_;
}

// -------------------------------------------------------------------

// MoveMsg

// .MsgType msg_type = 1;
inline void MoveMsg::clear_msg_type() {
  _impl_.msg_type_ = 0;
}
inline ::MsgType MoveMsg::_internal_msg_type() const {
  return static_cast< ::MsgType >(_impl_.msg_type_);
}
inline ::MsgType MoveMsg::msg_type() const {
  // @@protoc_insertion_point(field_get:MoveMsg.msg_type)
  return _internal_msg_type();
}
inline void MoveMsg::_internal_set_msg_type(::MsgType value) {
  
  _impl_.msg_type_ = value;
}
inline void MoveMsg::set_msg_type(::MsgType value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:MoveMsg.msg_type)
}

// int32 move_x = 2;
inline void MoveMsg::clear_move_x() {
  _impl_.move_x_ = 0;
}
inline int32_t MoveMsg::_internal_move_x() const {
  return _impl_.move_x_;
}
inline int32_t MoveMsg::move_x() const {
  // @@protoc_insertion_point(field_get:MoveMsg.move_x)
  return _internal_move_x();
}
inline void MoveMsg::_internal_set_move_x(int32_t value) {
  
  _impl_.move_x_ = value;
}
inline void MoveMsg::set_move_x(int32_t value) {
  _internal_set_move_x(value);
  // @@protoc_insertion_point(field_set:MoveMsg.move_x)
}

// int32 move_y = 3;
inline void MoveMsg::clear_move_y() {
  _impl_.move_y_ = 0;
}
inline int32_t MoveMsg::_internal_move_y() const {
  return _impl_.move_y_;
}
inline int32_t MoveMsg::move_y() const {
  // @@protoc_insertion_point(field_get:MoveMsg.move_y)
  return _internal_move_y();
}
inline void MoveMsg::_internal_set_move_y(int32_t value) {
  
  _impl_.move_y_ = value;
}
inline void MoveMsg::set_move_y(int32_t value) {
  _internal_set_move_y(value);
  // @@protoc_insertion_point(field_set:MoveMsg.move_y)
}

// bool validation = 4;
inline void MoveMsg::clear_validation() {
  _impl_.validation_ = false;
}
inline bool MoveMsg::_internal_validation() const {
  return _impl_.validation_;
}
inline bool MoveMsg::validation() const {
  // @@protoc_insertion_point(field_get:MoveMsg.validation)
  return _internal_validation();
}
inline void MoveMsg::_internal_set_validation(bool value) {
  
  _impl_.validation_ = value;
}
inline void MoveMsg::set_validation(bool value) {
  _internal_set_validation(value);
  // @@protoc_insertion_point(field_set:MoveMsg.validation)
}

// -------------------------------------------------------------------

// MessageMsg

// .MsgType msg_type = 1;
inline void MessageMsg::clear_msg_type() {
  _impl_.msg_type_ = 0;
}
inline ::MsgType MessageMsg::_internal_msg_type() const {
  return static_cast< ::MsgType >(_impl_.msg_type_);
}
inline ::MsgType MessageMsg::msg_type() const {
  // @@protoc_insertion_point(field_get:MessageMsg.msg_type)
  return _internal_msg_type();
}
inline void MessageMsg::_internal_set_msg_type(::MsgType value) {
  
  _impl_.msg_type_ = value;
}
inline void MessageMsg::set_msg_type(::MsgType value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:MessageMsg.msg_type)
}

// string message = 2;
inline void MessageMsg::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& MessageMsg::message() const {
  // @@protoc_insertion_point(field_get:MessageMsg.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageMsg::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MessageMsg.message)
}
inline std::string* MessageMsg::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:MessageMsg.message)
  return _s;
}
inline const std::string& MessageMsg::_internal_message() const {
  return _impl_.message_.Get();
}
inline void MessageMsg::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageMsg::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageMsg::release_message() {
  // @@protoc_insertion_point(field_release:MessageMsg.message)
  return _impl_.message_.Release();
}
inline void MessageMsg::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MessageMsg.message)
}

// int32 clientId = 3;
inline void MessageMsg::clear_clientid() {
  _impl_.clientid_ = 0;
}
inline int32_t MessageMsg::_internal_clientid() const {
  return _impl_.clientid_;
}
inline int32_t MessageMsg::clientid() const {
  // @@protoc_insertion_point(field_get:MessageMsg.clientId)
  return _internal_clientid();
}
inline void MessageMsg::_internal_set_clientid(int32_t value) {
  
  _impl_.clientid_ = value;
}
inline void MessageMsg::set_clientid(int32_t value) {
  _internal_set_clientid(value);
  // @@protoc_insertion_point(field_set:MessageMsg.clientId)
}

// -------------------------------------------------------------------

// OrderMsg

// .MsgType msg_type = 1;
inline void OrderMsg::clear_msg_type() {
  _impl_.msg_type_ = 0;
}
inline ::MsgType OrderMsg::_internal_msg_type() const {
  return static_cast< ::MsgType >(_impl_.msg_type_);
}
inline ::MsgType OrderMsg::msg_type() const {
  // @@protoc_insertion_point(field_get:OrderMsg.msg_type)
  return _internal_msg_type();
}
inline void OrderMsg::_internal_set_msg_type(::MsgType value) {
  
  _impl_.msg_type_ = value;
}
inline void OrderMsg::set_msg_type(::MsgType value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:OrderMsg.msg_type)
}

// int32 white = 2;
inline void OrderMsg::clear_white() {
  _impl_.white_ = 0;
}
inline int32_t OrderMsg::_internal_white() const {
  return _impl_.white_;
}
inline int32_t OrderMsg::white() const {
  // @@protoc_insertion_point(field_get:OrderMsg.white)
  return _internal_white();
}
inline void OrderMsg::_internal_set_white(int32_t value) {
  
  _impl_.white_ = value;
}
inline void OrderMsg::set_white(int32_t value) {
  _internal_set_white(value);
  // @@protoc_insertion_point(field_set:OrderMsg.white)
}

// int32 black = 3;
inline void OrderMsg::clear_black() {
  _impl_.black_ = 0;
}
inline int32_t OrderMsg::_internal_black() const {
  return _impl_.black_;
}
inline int32_t OrderMsg::black() const {
  // @@protoc_insertion_point(field_get:OrderMsg.black)
  return _internal_black();
}
inline void OrderMsg::_internal_set_black(int32_t value) {
  
  _impl_.black_ = value;
}
inline void OrderMsg::set_black(int32_t value) {
  _internal_set_black(value);
  // @@protoc_insertion_point(field_set:OrderMsg.black)
}

// bool gamestart = 4;
inline void OrderMsg::clear_gamestart() {
  _impl_.gamestart_ = false;
}
inline bool OrderMsg::_internal_gamestart() const {
  return _impl_.gamestart_;
}
inline bool OrderMsg::gamestart() const {
  // @@protoc_insertion_point(field_get:OrderMsg.gamestart)
  return _internal_gamestart();
}
inline void OrderMsg::_internal_set_gamestart(bool value) {
  
  _impl_.gamestart_ = value;
}
inline void OrderMsg::set_gamestart(bool value) {
  _internal_set_gamestart(value);
  // @@protoc_insertion_point(field_set:OrderMsg.gamestart)
}

// -------------------------------------------------------------------

// ChessMapMsg

// .MsgType msg_type = 1;
inline void ChessMapMsg::clear_msg_type() {
  _impl_.msg_type_ = 0;
}
inline ::MsgType ChessMapMsg::_internal_msg_type() const {
  return static_cast< ::MsgType >(_impl_.msg_type_);
}
inline ::MsgType ChessMapMsg::msg_type() const {
  // @@protoc_insertion_point(field_get:ChessMapMsg.msg_type)
  return _internal_msg_type();
}
inline void ChessMapMsg::_internal_set_msg_type(::MsgType value) {
  
  _impl_.msg_type_ = value;
}
inline void ChessMapMsg::set_msg_type(::MsgType value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:ChessMapMsg.msg_type)
}

// repeated int32 map = 2;
inline int ChessMapMsg::_internal_map_size() const {
  return _impl_.map_.size();
}
inline int ChessMapMsg::map_size() const {
  return _internal_map_size();
}
inline void ChessMapMsg::clear_map() {
  _impl_.map_.Clear();
}
inline int32_t ChessMapMsg::_internal_map(int index) const {
  return _impl_.map_.Get(index);
}
inline int32_t ChessMapMsg::map(int index) const {
  // @@protoc_insertion_point(field_get:ChessMapMsg.map)
  return _internal_map(index);
}
inline void ChessMapMsg::set_map(int index, int32_t value) {
  _impl_.map_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChessMapMsg.map)
}
inline void ChessMapMsg::_internal_add_map(int32_t value) {
  _impl_.map_.Add(value);
}
inline void ChessMapMsg::add_map(int32_t value) {
  _internal_add_map(value);
  // @@protoc_insertion_point(field_add:ChessMapMsg.map)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ChessMapMsg::_internal_map() const {
  return _impl_.map_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ChessMapMsg::map() const {
  // @@protoc_insertion_point(field_list:ChessMapMsg.map)
  return _internal_map();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ChessMapMsg::_internal_mutable_map() {
  return &_impl_.map_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ChessMapMsg::mutable_map() {
  // @@protoc_insertion_point(field_mutable_list:ChessMapMsg.map)
  return _internal_mutable_map();
}

// int32 step = 3;
inline void ChessMapMsg::clear_step() {
  _impl_.step_ = 0;
}
inline int32_t ChessMapMsg::_internal_step() const {
  return _impl_.step_;
}
inline int32_t ChessMapMsg::step() const {
  // @@protoc_insertion_point(field_get:ChessMapMsg.step)
  return _internal_step();
}
inline void ChessMapMsg::_internal_set_step(int32_t value) {
  
  _impl_.step_ = value;
}
inline void ChessMapMsg::set_step(int32_t value) {
  _internal_set_step(value);
  // @@protoc_insertion_point(field_set:ChessMapMsg.step)
}

// -------------------------------------------------------------------

// ResultMsg

// .MsgType msg_type = 1;
inline void ResultMsg::clear_msg_type() {
  _impl_.msg_type_ = 0;
}
inline ::MsgType ResultMsg::_internal_msg_type() const {
  return static_cast< ::MsgType >(_impl_.msg_type_);
}
inline ::MsgType ResultMsg::msg_type() const {
  // @@protoc_insertion_point(field_get:ResultMsg.msg_type)
  return _internal_msg_type();
}
inline void ResultMsg::_internal_set_msg_type(::MsgType value) {
  
  _impl_.msg_type_ = value;
}
inline void ResultMsg::set_msg_type(::MsgType value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:ResultMsg.msg_type)
}

// int32 color = 2;
inline void ResultMsg::clear_color() {
  _impl_.color_ = 0;
}
inline int32_t ResultMsg::_internal_color() const {
  return _impl_.color_;
}
inline int32_t ResultMsg::color() const {
  // @@protoc_insertion_point(field_get:ResultMsg.color)
  return _internal_color();
}
inline void ResultMsg::_internal_set_color(int32_t value) {
  
  _impl_.color_ = value;
}
inline void ResultMsg::set_color(int32_t value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:ResultMsg.color)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::MsgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgType>() {
  return ::MsgType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_move_2eproto
